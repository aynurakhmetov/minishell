https://cloud.mail.ru/public/58oi/3DQKPsUXi - видео обучающее Никиты о минишелл

Важные функции:
1. fork - создает дочерний процесс. Создается копия нашего кода со всей памятью и переменными.
https://www.opennet.ru/man.shtml?topic=fork&category=2 - fork
https://www.opennet.ru/docs/RUS/linux_parallel/node7.html
У них нет общей области видимости. Что вы измените в дочернем процессе, то не изменится в родительском.
pid - это id процесса, proces id.
При вызове fork в родительском провессе вернется pid дочернего процесса.
А в дочернем процессе вернется pid равный 0;

2. wait - нужен на случай, когда родительский процесс должен подождать дочерний.
Есть 2 варианта - wait и waitpid.

pid_t wait(int *status); - status нужен для того, чтобы узнать с каким кодом, каким статусом вышел наш дочерний процесс.
pid_t waitpid(pid_t pid, int *status, int options);
https://www.opennet.ru/man.shtml?topic=waitpid&category=2&russian=0

3. execve - наша самая основная функция
https://www.opennet.ru/docs/RUS/linux_parallel/node8.html - execve
int execve(char *name, char *arv[], char *envp[]);

name - это имя нашего исполняемого файла
argc - это тот двухмерный массив, который придет в main исполняемого файла, это те аргументы, которые вы будете передавать командам
envp - в мейн можно передать еще третий параметр - это переменные окружения.
Мы можем из нашего мейника minishell вызвать условный ls.
execve запускает другие бинарники, которые у нас имеются на компьютере.

kill - https://www.opennet.ru/man.shtml?topic=kill&category=2 - посылает сигнал процессу.

fork, pipe, execve, dup/dup2 - эти 4 обязательно нужны

4. dup - создать дубликат файлового дескриптора. https://www.opennet.ru/man.shtml?topic=dup2&category=2&russian=0
мы посылаем туда fd терминала, dup вернет дубликат, чаще всего 3, цифру нового фдшника.

Логика программы:
Этап парсинга.
Реализация build-in команд - echo, cd, pwd, export, unset, env, exit. Мы их должны реализовать сами.
Сигналы - ctrl-C, ctrl-D, ctrl-/
Запуск внешних программ
Логика редиректов\пайпов
Обработка ошибок

echo -n - флаг убирает перенос строки.

Обработка ошибок. 
сommand not found. 
No such file or directory.
Permission denied.

syntax error near unexpected token newline

поделить задачи с тиммейтом
Точки входа и выхода ваших кусов кода
В каком виде вы передаете данные
Определить структуры данных, с оторыми вы будете работать

Этапы парсинга.
1. Переменные окружения.
2. Одинарные и двойные кавычки. Их отличия.
3. Экранирование
4. Пайпы\редиректы
5. semicolon


Переменные окружения лучше перемаллочить в свой двумерный массив.
echo $path выведет содержимое переменной path
echo $path$qwe выведет содержимое двух переменных (если они обе существуют) NB! $path$qwe - это один аргумент. Два аргумента появляются когда они разделены пробелом. "qwe"'qwe' - это один аргумент.
echo $pathqwe ничего не выведет, если такой переменной не существует
Баш парсит ключ до спец символов. ' " \ $ пробел Кавычки входят в спецсимволы.

'' - сильные кавычки
В каком виде записали информацию в одинарных кавычках, в таком жже виде она ппадет дальше.
Там ничего нигде не парсится. Не работает экранирование, $ и другие спецсимволы.

"" - слабые кавычки
В двойных кавычках подставляется переменные. Обрабатываются пробелы как символы, в отличие от аргументов без кавычек. (пробелы в кавычках считаются как символы.)

Важно! Как только bash увиде двойные кавычки, он обрабатывает всю информацию как в двойных кавычках.
" '  $path '  "  - в этом случае path подставится

Экранирование.
Отличается экранирование без кавычек, в двойных кавычках и в одинарных кавычках.
\t "\t" '\t'

\t - без кавычек, экранируется абсолютно всего
'\t'- в одинарных кавычках, не экранируется ничего

В двойных кавычках экранируется двойной слэш \ " $  - Например, echo "\\" выведет \.  Экранируется двойная кавычка "\" - в данном примере вторая кавычка будет экранирована и баш попросит ввести вторую парную.
\t в двойных кавычках экранироватся не будет

semicolon ;

Если мы хотим вызвать две разных команды, но в одной командной строке, то мы разделяем их точкой с запятой ;  Например pwd ; pwd выполнится , а pwd pwd выдаст ошибку, что слишком много аргуметов. ; похожа на && -, например, pwd && pwd
Если без точки с запятой баш подумает, что я передал два аргумента и попытается обработать их вместе.
ВАЖНО! Если встретили точку с запятой вне кавычек, то нужно сразу отработать ээту программу.
Плоха практика использовать сплит или измененный сплит, лучше идти посимвольно.

Команды с путем и без.

ls и ./ls будут работать по-разному. В первом случае это команды ls, а во втором случае какой-то файл ls в текущей директории.
 важный тест unset PATH далее ls в текуще директории ничего не выведет , а /bin/ls сработает.

/bin/       ./ls - валидно, т.к. это аналогично /bin/./ls

Проверяем CMP три случая ../ls ./ls и / , и еси один из этих случаев, то в path даже не лезем

Принцип парсинга.
echo "  $PATH "'     $PATH   '

Аргументы храним в двумерном масиве чаров.
echo будет первый аргумент. Используем при парсинге реалллок.

встретив " - используем другую функцию, которая исппользует переменные окружения. Пробел уже не пропускаем, а
добавляем к аргументу. Важно , чтобы к массив попал не $PATH, а само значение PATH. Встретил вторую ", выхожу из функции, которая парсит по аргументам в двойных кавычках.

В итоге -   /Users/ajeanett/.brew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/munki      $PATH
все это, начиная с пробелов в двойных кавычках будет вторым аргументом.

e''c''h''o hello - вызовет echo и напечатает hello.
Это наглядно показывает, что разделителями является только пробел и спецсимволы. Кавычки не являются символям разделителя.


Дочерние процессы.

Зачем?
Если мы не сделаем fork и выполним execve в родительском процессе, наш минишелл будет способен воспроивести только одну команду. Т.к. execve делает так, что процесс, в котором апустился execve умирает.
Мы делаем fork и в дочернем процессе запускаем execve.

Что такое дочерний процесс?
Копия родительского процесса.

Что делает родиель?
Ждет. В большинстве случаев родитель будет делать wait, будет ждать, когда дочерний процесс отработает.

Как не обзавестись лишним процессом?
Если мы не будем следить за дочерним процессом и "доверимся" execve может случиться, что execve выйдет со статуом не 0,
execve вернет статус -1 и дочерний процесс не умрет. И все последующие функции будут выполняться 2 раза.
Если execve вырнул -1, делаем принудительный exit.

Pid и зачем он нужен.
pid - это переменная process id, которую возвращает fork
Для отслеживания процессов.

built-in не обязательно вызывать в дочернем процессе, т.к. они не будут вызываться через execve.
built-in - это наши функции
Дочерний процесс будет нужен только для execve и, возможно, для пайпов.

Пайпы. |

Пайп - труба, в которую приходит информация и выходит из нее.
Функция pipe принимает в себя массив из двух интов.
int fd[2];

pipe(fd);

fd[1] - в который пишем
fd[0] - из которого читаем
выставили flag_pipe = 1;

Также, как и с терминалом. У нас есть стандартный ввод (0) и вывод (1).

При работе c пайпами нам поможет dup2.
int dup2(int oldfd, int newfd);

int dup2(fd[1], 1); - fd номер 1 указывает теперь на fd пайпа.  Я подменю первый fd на первый fd пайпа

Если я буду писать в первый fd, информация будет попадать не в терминал, она будет попадать в файловый дескриптор пайпа.

Пример:
ls | grep

Если встретил pipe (flag_pipe == 1)
    вызвать (pid = fork) - создаем дочерний процесс

    Если (pid == 0):
        dup2(fd[1]; 1);
        close(fd[0]); - fd[0] в дочернем процессе не нужен
        execve("/bin/ls" + аргументы);
        close(fd[1]);

    Если (pid != 0):  -- то есть это родительский процесс
        dup2(fd[0]; 0); -- я говорю родителю, что нулевой fd равен fd из пайпа.
        Это нужно, чтобы grep в следующей интерации читал уже не с терминального fd, а с fd пайпа
        close(fd[1]);
        wait(...);
        close(fd[0]);

ВАЖНО! В самом начал нам необходимо сохранить 0 и 1 fd во временной переменной, например, temp_fd.
Чтобы потом вернуть его на место в род процессе после выполнения команды. Иначе будет ошибка bad file descriptor
temp_0_fd = dup(0);

execve("/usr/bin/grep", аргументы);
dup2(temp_0_fd,0);


Итого:
Получил ls, его распарсил. Встретил пайп, получил фдшники пайпа. (вызвал функцию pipe(fd))
brake из парсинга

Можно сделать структуру

struct fd {
int fd0 = 0;  равен нулевому изначальному fd
int fd1 = 1;
}

Редиректы. 
Похоже на пайпы, только если пайпы - это два фдшника, редирект - это один фдшник.

">" - правый редирект - это запись.

int fd;
fd = open(filename, флаги, права);

struct.fd1 = fd;
flag_redir = 1;

Советы от соника.

1. Не бросаться сразу писать код.
2. Защита функций, использующих системные вызовы. fork, wait, kill, dup, execve использую системные вызовы
3. Бойтесь утечек памяти и фдшников.
4. Итеративный подход к написанию программы.
5. Работа сс гитом вместе с напарником.
6. Постарайтесь сразу придумать и обработать неприятные кейсы.

локальные и экспортируемые переменные









